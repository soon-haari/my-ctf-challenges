from PIL import Image
from tqdm import trange
from copy import copy
import sys
from hashlib import sha256

sys.setrecursionlimit(10**6)

side_real = 100
loops = 30
side = side_real * 2 + 1


# https://keesiemeijer.github.io/maze-generator/#generate
# parameter 1/100/100/diagonal/none/30
m = list(Image.open('maze.png').getdata())
m = [int(block == (0, 0, 0, 255)) for block in m]

assert len(m) == side**2

m = [m[side * i:side * (i + 1)] for i in range(side)]
assert m[1][0] == 0 and m[-2][-1] == 0



def dfs(u, p, color, par, cycles):
	path.append(u)

	if u == [side - 2, side - 1]:
		route.append(copy(path))

	if color[u[0]][u[1]] == 2:
		return
 
	if color[u[0]][u[1]] == 1:
		v = []
		cur = p
		v.append(cur)
 
		while cur != u:
			cur = par[cur[0]][cur[1]]
			v.append(cur)
		cycles.append(v)
		paths.append(copy(path))
 
		return
 
	par[u[0]][u[1]] = p
	color[u[0]][u[1]] = 1

	i, j = u
	xy = [[i, j-1], [i, j+1], [i-1, j], [i+1, j]]
	for v in xy:
		if not ((0 <= v[0] < side) and (0 <= v[1] < side)):
			continue
		if m[v[0]][v[1]]:
			continue
		if v == par[u[0]][u[1]]:
			continue

		dfs(v, u, color, par, cycles)
		path.pop()
 
	color[u[0]][u[1]] = 2

cycles = []
paths = []
path = []
route = []
color = [[0] * side for _ in range(side)]
par = [[0] * side for _ in range(side)]

dfs([1, 0], -1, color, par, cycles)

assert len(cycles) == loops
assert len(route) == 1
baseroute = route[0]
assert baseroute[0] == [1, 0] and baseroute[-1] == [side - 2, side - 1]

from sage.all import ZZ, Matrix

p = ZZ(2**255 - 19)

def str2fp(msg):
	return int.from_bytes(sha256(msg.encode()).digest()) % p

name = "soon_haari"
key = "hungry"

init = str2fp(name)

def calc(route):
	state = ZZ(init)
	assert route[0] == [1, 0] and route[-1] == [side - 2, side - 1]

	l = len(route) - 1

	route_str = ""

	for i in range(l):
		y, x = route[i]
		assert m[y][x] == 0

		diff = route[i + 1][0] - route[i][0], route[i + 1][1] - route[i][1]
		if diff == (0, 1):
			state += 1337
			route_str += "d"
		elif diff == (0, -1):
			state -= 1337
			route_str += "a"
		elif diff == (1, 0):
			state *= 1337
			route_str += "s"
		elif diff == (-1, 0):
			state /= ZZ(1337)
			route_str += "w"
		else:
			print("wrong")
			exit()
		state %= p

	return state, route_str

base_st = calc(baseroute)[0]

diffs = []

for i in range(loops):
	cycle = cycles[i]
	path = paths[i]
	pathback = path[::-1][1:-1]

	new_route = path + cycle + pathback + baseroute

	new_st = calc(new_route)[0]
	diff = (new_st - base_st) % p

	diffs.append(diff)

def make_route(bias):
	new_route = []

	for i in range(loops):
		cycle = cycles[i]
		backcycle = cycle[:-1][::-1] + [cycle[-1]]
		path = paths[i]
		pathback = path[::-1][1:-1]

		new_route += path
		if bias[i] >= 0:
			new_route += cycle * bias[i]
		else:
			new_route += backcycle * abs(bias[i])
		new_route += pathback
	new_route += baseroute

	res, route_str = calc(new_route)

	myres = base_st
	for i in range(loops):
		myres += bias[i] * diffs[i]
	myres %= p

	assert res == myres

	return route_str

TEST = False
if TEST:
	import random

	bias = [random.randrange(-30, 30) for _ in range(loops)]

	make_route(bias)

target = (str2fp(key) - base_st) % p

M = Matrix(loops + 2, loops + 2)

weight = 50000
weight2 = 100000
for i in range(loops):
	M[i, i] = 1
	M[i, loops] = diffs[i] * weight
M[loops, loops] = p * weight
M[loops + 1, loops] = -target * weight
M[loops + 1, loops + 1] = weight2

M = M.LLL()

for v in M:
	if v[-1] == weight2:
		assert v[-2] == 0
		v = v[:-2]
		break
else:
	print("fail")
	exit()

chk = base_st
for i in range(loops):
	chk += v[i] * diffs[i]
chk %= p

assert chk == str2fp(key)

final_route = make_route(v)




from pwn import process, remote

# io = process(["python3", "chall.py"])
io = remote("localhost", 8786)

io.sendline(name.encode())
io.sendline(key.encode())

batch = 10000

cnt = 0
for i in range(0, len(final_route), batch):
	to_send = final_route[i:i + batch]

	io.sendline(to_send.encode())
	cnt += 1

io.recvuntil(b"> " * cnt)

io.interactive()

