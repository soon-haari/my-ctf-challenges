

# This file was *autogenerated* from the file ex.sage
from sage.all_cmdline import *   # import sage library

_sage_const_118549579796788515994414649236369265269780996946642393375504713268996543836492572997532134962413661837052222678148616587175464294656866212083879163757595198637277720148049394221272652120067946542481202345536577647854319626518830885330021003068475187962796231844540355486949322214342559093662111580693859480 = Integer(118549579796788515994414649236369265269780996946642393375504713268996543836492572997532134962413661837052222678148616587175464294656866212083879163757595198637277720148049394221272652120067946542481202345536577647854319626518830885330021003068475187962796231844540355486949322214342559093662111580693859480); _sage_const_2 = Integer(2); _sage_const_256 = Integer(256); _sage_const_0 = Integer(0); _sage_const_10 = Integer(10); _sage_const_3 = Integer(3); _sage_const_1 = Integer(1); _sage_const_1024 = Integer(1024); _sage_const_16 = Integer(16); _sage_const_4 = Integer(4); _sage_const_27 = Integer(27); _sage_const_5 = Integer(5); _sage_const_11 = Integer(11); _sage_const_19 = Integer(19); _sage_const_31 = Integer(31); _sage_const_53 = Integer(53); _sage_const_349 = Integer(349); _sage_const_3517 = Integer(3517); _sage_const_673063 = Integer(673063); _sage_const_2745521 = Integer(2745521); _sage_const_55050007 = Integer(55050007); _sage_const_377214161 = Integer(377214161); _sage_const_20360574113233812481685439263671789261817936006577330964336962473923517498497934703871787394487722776320255054270961305081467007402360235551783832230924586862762774225807963988136283635452040243476642685484746146943283864002000148190191387194458228613505267579173 = Integer(20360574113233812481685439263671789261817936006577330964336962473923517498497934703871787394487722776320255054270961305081467007402360235551783832230924586862762774225807963988136283635452040243476642685484746146943283864002000148190191387194458228613505267579173); _sage_const_3692983360407686094702508373879 = Integer(3692983360407686094702508373879); _sage_const_2717597692908121319788497985451 = Integer(2717597692908121319788497985451); _sage_const_324094280281900209908870811008292068290746348301400744740589987 = Integer(324094280281900209908870811008292068290746348301400744740589987); _sage_const_882753962084249870019779631633 = Integer(882753962084249870019779631633); _sage_const_3268297554085538840095770315766 = Integer(3268297554085538840095770315766); _sage_const_1688818121111580066310934554129 = Integer(1688818121111580066310934554129); _sage_const_255 = Integer(255); _sage_const_130 = Integer(130); _sage_const_860437940168965817900625942259 = Integer(860437940168965817900625942259); _sage_const_7 = Integer(7); _sage_const_32 = Integer(32); _sage_const_12 = Integer(12)
enc_flag = bytes.fromhex('5ade26f7b0461ec24e2f6a328be00be8e49e7707b5533c8da3b42bbb41a2aeb4ec8a63c2d625f891b6cce1c6842bda77a31957351aa90525385df3d80431db3c9c73183207267adccf016cbda326cf872c365903d63e20fab0f31bb2ef19b31ea151db097514b49f3fdbc05b8a26ae02')
o = _sage_const_118549579796788515994414649236369265269780996946642393375504713268996543836492572997532134962413661837052222678148616587175464294656866212083879163757595198637277720148049394221272652120067946542481202345536577647854319626518830885330021003068475187962796231844540355486949322214342559093662111580693859480 

dat = open("output.txt", "r").readlines()[_sage_const_2 :]
assert len(dat) == _sage_const_256 

from ast import literal_eval

dat = [literal_eval(d) for d in dat]

n = _sage_const_0 

for i in range(_sage_const_10 ):
	M = []
	for j in range(_sage_const_3 ):
		x, y = dat[i + j]
		M.append([x, _sage_const_1 , x**_sage_const_3  - y**_sage_const_2 ])
	det = Matrix(M).determinant()
	n = gcd(n, det)

assert n.bit_length() == _sage_const_1024 

M = []
r = []
for i in range(_sage_const_2 ):
	x, y = dat[i]
	M.append([x, _sage_const_1 ])
	r.append(y**_sage_const_2  - x**_sage_const_3 )
a, b = map(ZZ, Matrix(Zmod(n), M).solve_right(vector(Zmod(n), r)))

for x, y in dat:
	assert (y**_sage_const_2  - (x**_sage_const_3  + a * x + b)) % n == _sage_const_0 

E = EllipticCurve(Zmod(n), [a, b])
P = E(dat[_sage_const_0 ])

# P * 1
# Error
# discriminant not coprime to modulus, thus include singular curve
singular_mod = gcd(n, -_sage_const_16  * (_sage_const_4  * a**_sage_const_3  + _sage_const_27  * b**_sage_const_2 ))
# 3562548874780288796769030192977

original_mod = n

p1 = singular_mod
assert is_prime(p1)
assert n % p1 == _sage_const_0 
n //= p1
assert n % p1 != _sage_const_0 

from sage.rings.factorint import factor_trial_division

# o_facs = list(factor_trial_division(o, 2^30))
# print(o_facs)
o_facs = [(_sage_const_2 , _sage_const_3 ), (_sage_const_3 , _sage_const_2 ), (_sage_const_5 , _sage_const_1 ), (_sage_const_11 , _sage_const_1 ), (_sage_const_19 , _sage_const_1 ), (_sage_const_31 , _sage_const_1 ), (_sage_const_53 , _sage_const_1 ), (_sage_const_349 , _sage_const_1 ), (_sage_const_3517 , _sage_const_1 ), (_sage_const_673063 , _sage_const_1 ), (_sage_const_2745521 , _sage_const_1 ), (_sage_const_55050007 , _sage_const_1 ), (_sage_const_377214161 , _sage_const_1 ), (_sage_const_20360574113233812481685439263671789261817936006577330964336962473923517498497934703871787394487722776320255054270961305081467007402360235551783832230924586862762774225807963988136283635452040243476642685484746146943283864002000148190191387194458228613505267579173 , _sage_const_1 )]
iter_range = [range(v[_sage_const_1 ] + _sage_const_1 ) for v in o_facs[:-_sage_const_1 ]]

E = EllipticCurve(Zmod(n), [a, b])
P = E(dat[_sage_const_0 ])

import itertools
from tqdm import tqdm, trange
import time


# for p^k | k
# p^(k - 1) | o
# the following can factor to every p^k

'''
gs = set()
for it in tqdm(itertools.product(*iter_range)):
	mul = o
	for i in range(len(it)):
		mul //= o_facs[i][0]^it[i]
	assert o % mul == 0

	g = gcd(ZZ((P * (mul - 1))[0] - P[0]), n)

	if g == 1:
		continue

	gs.add(g)

for g in gs:
	for exp in range(100, 0, -1):
		if g^(1 / exp) in ZZ:
			p = ZZ(g^(1 / exp))
			if is_prime(p):
				break
	else:
		continue
	print(p, exp)
exit()


2717597692908121319788497985451 3
3692983360407686094702508373879 2
324094280281900209908870811008292068290746348301400744740589987 2
'''

p2 = _sage_const_3692983360407686094702508373879 
p3 = _sage_const_2717597692908121319788497985451 
p4 = _sage_const_324094280281900209908870811008292068290746348301400744740589987 

assert original_mod == p1**_sage_const_1  * p2**_sage_const_2  * p3**_sage_const_3  * p4**_sage_const_2 

correct_idx = _sage_const_2 
# index to compare



# 1. p1, singular curve

# E = EllipticCurve(GF(p1), [a, b])
# ArithmeticError: y^2 = x^3 + 3250676836264928831089904907357*x + 3033513073637482920220005561471 defines a singular curve
Fp = GF(p1)
P = PolynomialRing(Fp, names=('x',)); (x,) = P._first_ngens(1)
poly = x**_sage_const_3  + a * x + b

# print(factor(poly))
# exit()
# (x + 588502641389499913346519754422) * (x + 3268297554085538840095770315766)^2
# ((x + 3268297554085538840095770315766) + 882753962084249870019779631633) * (x + 3268297554085538840095770315766)^2
alpha = _sage_const_882753962084249870019779631633 

# print(Fp(882753962084249870019779631633).sqrt())
# sqrt882753962084249870019779631633
# need to extend to Fp2
Fp2 = GF(p1**_sage_const_2 )
alpha = Fp2(alpha)
asqrt = alpha.sqrt()


def singular_map(P):
	x, y = map(Fp2, P)
	x = x + _sage_const_3268297554085538840095770315766 
	res = (y + asqrt * x) / (y - asqrt * x)
	assert res.multiplicative_order() == p1 + _sage_const_1 
	return res

dat_p1 = [singular_map(P) for P in dat]
'''
st = time.time()
dlog = dat_p1[correct_idx + 1].log(dat_p1[correct_idx])
en = time.time()
print(f"{dlog = }, took {en - st:.2f}s.")
exit()
'''
# dlog = 1688818121111580066310934554129, took 4.04s.

dlog = _sage_const_1688818121111580066310934554129 
assert gcd(dlog, p1 + _sage_const_1 ) == _sage_const_1 

res_p1 = [dat_p1[i]**dlog == dat_p1[i + _sage_const_1 ] for i in range(_sage_const_255 )]
assert _sage_const_255  > res_p1.count(True) > _sage_const_130 



# 2. p2^2, supersingular curve, MOV attack

E = EllipticCurve(GF(p2), [a, b])
assert E.is_supersingular()
# print(E)
# Elliptic Curve defined by y^2 = x^3 + 986063441805532048667620077607*x + 387728752840944215658366504283 over Finite Field of size 3692983360407686094702508373879
o = E.order()
assert o == p2 + _sage_const_1 
Fp2 = GF(p2**_sage_const_2 )
E = EllipticCurve(Fp2, [a, b])
dat_p2 = [E(P) for P in dat]
'''
while True:
	x = Fp2(randrange(p2))
	G = E.lift_x(x)
	if G[1] in GF(p2):
		continue
	if G.order() != p2 + 1:
		continue
	break
w1 = dat_p2[correct_idx].weil_pairing(G, p2 + 1)
w2 = dat_p2[correct_idx + 1].weil_pairing(G, p2 + 1)
st = time.time()
dlog = w2.log(w1)
en = time.time()
print(f"{dlog = }, took {en - st:.2f}s.")
exit()
'''
# dlog = 860437940168965817900625942259, took 403.81s.


dlog = _sage_const_860437940168965817900625942259 
res_p2 = [dat_p2[i] * dlog == dat_p2[i + _sage_const_1 ] for i in range(_sage_const_255 )]
assert _sage_const_255  > res_p2.count(True) > _sage_const_130 


def dlog_power(P, Q, p, o, E):
	EQp = E.change_ring(Qp(p))
	Pmul = EQp(P) * o
	Qmul = EQp(Q) * o

	dlog = ZZ((Qmul[_sage_const_0 ] / Qmul[_sage_const_1 ]) / (Pmul[_sage_const_0 ] / Pmul[_sage_const_1 ]))

	# assert Pmul * dlog == Qmul
	return dlog

E = EllipticCurve(Zmod(p2**_sage_const_2 ), [a, b])
dat_p2 = [E(P) for P in dat]

dlog_correct = dlog_power(dat_p2[correct_idx + _sage_const_1 ], dat_p2[correct_idx], p2, o, E)
res_p2_power = [dlog_power(dat_p2[i + _sage_const_1 ], dat_p2[i], p2, o, E) == dlog_correct for i in trange(_sage_const_255 )]

assert _sage_const_255  > res_p2_power.count(True) > _sage_const_130 

# 3, p3^3, supersingular curve, distorsion map
E = EllipticCurve(GF(p3), [a, b])
assert E.is_supersingular()
# print(E)
# Elliptic Curve defined by y^2 = x^3 + 1508611169675476373544814188711 over Finite Field of size 2717597692908121319788497985451
# a = 0
o = E.order()
assert o == p3 + _sage_const_1 
Fp2 = GF(p3**_sage_const_2 )
z = Fp2(_sage_const_1 ).nth_root(_sage_const_3 )
assert z != _sage_const_1 

E = EllipticCurve(Fp2, [a, b])

def distorsion_map(P):
	x, y = P.xy()
	return E(x * z, y)

dat_p3 = [E(P) for P in dat]
assert dat_p3[_sage_const_0 ].order() == o
dat_p3_distorsion = [distorsion_map(P) for P in dat_p3]

res_p3 = [ dat_p3[correct_idx].weil_pairing(dat_p3_distorsion[i + _sage_const_1 ], p3 + _sage_const_1 )
		== dat_p3[correct_idx + _sage_const_1 ].weil_pairing(dat_p3_distorsion[i], p3 + _sage_const_1 )
		for i in trange(_sage_const_255 )]

assert _sage_const_255  > res_p3.count(True) > _sage_const_130 



E = EllipticCurve(Zmod(p3**_sage_const_3 ), [a, b])
dat_p3 = [E(P) for P in dat]

dlog_correct = dlog_power(dat_p3[correct_idx + _sage_const_1 ], dat_p3[correct_idx], p3, o, E)
res_p3_power = [dlog_power(dat_p3[i + _sage_const_1 ], dat_p3[i], p3, o, E) == dlog_correct for i in trange(_sage_const_255 )]

assert _sage_const_255  > res_p3_power.count(True) > _sage_const_130 



# 4, p4^2, supersingular curve, distorsion map
E = EllipticCurve(GF(p4), [a, b])
assert E.is_supersingular()
# print(E)
# Elliptic Curve defined by y^2 = x^3 + 201486157873867982115091945503042086637219431930076933476606014*x over Finite Field of size 324094280281900209908870811008292068290746348301400744740589987
# b = 0
o = E.order()
assert o == p4 + _sage_const_1 
Fp2 = GF(p4**_sage_const_2 )
z = Fp2(-_sage_const_1 ).nth_root(_sage_const_2 )

E = EllipticCurve(Fp2, [a, b])

def distorsion_map(P):
	x, y = P.xy()
	return E(-x, y * z)

dat_p4 = [E(P) for P in dat]
assert dat_p4[_sage_const_0 ].order() == o
dat_p4_distorsion = [distorsion_map(P) for P in dat_p4]

res_p4 = [ dat_p4[correct_idx].weil_pairing(dat_p4_distorsion[i + _sage_const_1 ], p4 + _sage_const_1 )
		== dat_p4[correct_idx + _sage_const_1 ].weil_pairing(dat_p4_distorsion[i], p4 + _sage_const_1 )
		for i in trange(_sage_const_255 )]

assert _sage_const_255  > res_p4.count(True) > _sage_const_130 


E = EllipticCurve(Zmod(p4**_sage_const_2 ), [a, b])
dat_p4 = [E(P) for P in dat]

dlog_correct = dlog_power(dat_p4[correct_idx + _sage_const_1 ], dat_p4[correct_idx], p4, o, E)
res_p4_power = [dlog_power(dat_p4[i + _sage_const_1 ], dat_p4[i], p4, o, E) == dlog_correct for i in trange(_sage_const_255 )]

assert _sage_const_255  > res_p4_power.count(True) > _sage_const_130 



# Final

res_list = [res_p1, res_p2, res_p2_power, res_p3, res_p3_power, res_p4, res_p4_power]

res = [all(r[i] for r in res_list) for i in range(_sage_const_255 )]

for i in range(_sage_const_7 ):
	res_without = []
	for j in range(_sage_const_7 ):
		if i == j:
			continue
		res_without.append(res_list[j])
	res_fail = [all(r[i] for r in res_without) for i in range(_sage_const_255 )]

	assert res_fail != res


from Crypto.Cipher import AES

for front in range(_sage_const_2 ):
	key = _sage_const_0 
	keybits = [front] + res
	for i in range(_sage_const_256 ):
		key += keybits[i] << i

	key = int(key).to_bytes(_sage_const_32 )

	flag = AES.new(key, AES.MODE_CTR, nonce=bytes(_sage_const_12 )).decrypt(enc_flag)
	try:
		print(flag.decode())
	except:
		pass

