enc_flag = bytes.fromhex('5ade26f7b0461ec24e2f6a328be00be8e49e7707b5533c8da3b42bbb41a2aeb4ec8a63c2d625f891b6cce1c6842bda77a31957351aa90525385df3d80431db3c9c73183207267adccf016cbda326cf872c365903d63e20fab0f31bb2ef19b31ea151db097514b49f3fdbc05b8a26ae02')
o = 118549579796788515994414649236369265269780996946642393375504713268996543836492572997532134962413661837052222678148616587175464294656866212083879163757595198637277720148049394221272652120067946542481202345536577647854319626518830885330021003068475187962796231844540355486949322214342559093662111580693859480

dat = open("output.txt", "r").readlines()[2:]
assert len(dat) == 256

from ast import literal_eval

dat = [literal_eval(d) for d in dat]

n = 0

for i in range(10):
	M = []
	for j in range(3):
		x, y = dat[i + j]
		M.append([x, 1, x^3 - y^2])
	det = Matrix(M).determinant()
	n = gcd(n, det)

assert n.bit_length() == 1024

M = []
r = []
for i in range(2):
	x, y = dat[i]
	M.append([x, 1])
	r.append(y^2 - x^3)
a, b = map(ZZ, Matrix(Zmod(n), M).solve_right(vector(Zmod(n), r)))

for x, y in dat:
	assert (y^2 - (x^3 + a * x + b)) % n == 0

E = EllipticCurve(Zmod(n), [a, b])
P = E(dat[0])

# P * 1
# Error
# discriminant not coprime to modulus, thus include singular curve
singular_mod = gcd(n, -16 * (4 * a^3 + 27 * b^2))
# 3562548874780288796769030192977

original_mod = n

p1 = singular_mod
assert is_prime(p1)
assert n % p1 == 0
n //= p1
assert n % p1 != 0

from sage.rings.factorint import factor_trial_division

# o_facs = list(factor_trial_division(o, 2^30))
# print(o_facs)
o_facs = [(2, 3), (3, 2), (5, 1), (11, 1), (19, 1), (31, 1), (53, 1), (349, 1), (3517, 1), (673063, 1), (2745521, 1), (55050007, 1), (377214161, 1), (20360574113233812481685439263671789261817936006577330964336962473923517498497934703871787394487722776320255054270961305081467007402360235551783832230924586862762774225807963988136283635452040243476642685484746146943283864002000148190191387194458228613505267579173, 1)]
iter_range = [range(v[1] + 1) for v in o_facs[:-1]]

E = EllipticCurve(Zmod(n), [a, b])
P = E(dat[0])

import itertools
from tqdm import tqdm, trange
import time


# for p^k | k
# p^(k - 1) | o
# the following can factor to every p^k

'''
gs = set()
for it in tqdm(itertools.product(*iter_range)):
	mul = o
	for i in range(len(it)):
		mul //= o_facs[i][0]^it[i]
	assert o % mul == 0

	g = gcd(ZZ((P * (mul - 1))[0] - P[0]), n)

	if g == 1:
		continue

	gs.add(g)

for g in gs:
	for exp in range(100, 0, -1):
		if g^(1 / exp) in ZZ:
			p = ZZ(g^(1 / exp))
			if is_prime(p):
				break
	else:
		continue
	print(p, exp)
exit()


2717597692908121319788497985451 3
3692983360407686094702508373879 2
324094280281900209908870811008292068290746348301400744740589987 2
'''

p2 = 3692983360407686094702508373879
p3 = 2717597692908121319788497985451
p4 = 324094280281900209908870811008292068290746348301400744740589987

assert original_mod == p1^1 * p2^2 * p3^3 * p4^2

correct_idx = 2
# index to compare



# 1. p1, singular curve

# E = EllipticCurve(GF(p1), [a, b])
# ArithmeticError: y^2 = x^3 + 3250676836264928831089904907357*x + 3033513073637482920220005561471 defines a singular curve
Fp = GF(p1)
P.<x> = PolynomialRing(Fp)
poly = x^3 + a * x + b

# print(factor(poly))
# exit()
# (x + 588502641389499913346519754422) * (x + 3268297554085538840095770315766)^2
# ((x + 3268297554085538840095770315766) + 882753962084249870019779631633) * (x + 3268297554085538840095770315766)^2
alpha = 882753962084249870019779631633

# print(Fp(882753962084249870019779631633).sqrt())
# sqrt882753962084249870019779631633
# need to extend to Fp2
Fp2 = GF(p1^2)
alpha = Fp2(alpha)
asqrt = alpha.sqrt()


def singular_map(P):
	x, y = map(Fp2, P)
	x = x + 3268297554085538840095770315766
	res = (y + asqrt * x) / (y - asqrt * x)
	assert res.multiplicative_order() == p1 + 1
	return res

dat_p1 = [singular_map(P) for P in dat]
'''
st = time.time()
dlog = dat_p1[correct_idx + 1].log(dat_p1[correct_idx])
en = time.time()
print(f"{dlog = }, took {en - st:.2f}s.")
exit()
'''
# dlog = 1688818121111580066310934554129, took 4.04s.

dlog = 1688818121111580066310934554129
assert gcd(dlog, p1 + 1) == 1

res_p1 = [dat_p1[i]^dlog == dat_p1[i + 1] for i in range(255)]
assert 255 > res_p1.count(True) > 130



# 2. p2^2, supersingular curve, MOV attack

E = EllipticCurve(GF(p2), [a, b])
assert E.is_supersingular()
# print(E)
# Elliptic Curve defined by y^2 = x^3 + 986063441805532048667620077607*x + 387728752840944215658366504283 over Finite Field of size 3692983360407686094702508373879
o = E.order()
assert o == p2 + 1
Fp2 = GF(p2^2)
E = EllipticCurve(Fp2, [a, b])
dat_p2 = [E(P) for P in dat]
'''
while True:
	x = Fp2(randrange(p2))
	G = E.lift_x(x)
	if G[1] in GF(p2):
		continue
	if G.order() != p2 + 1:
		continue
	break
w1 = dat_p2[correct_idx].weil_pairing(G, p2 + 1)
w2 = dat_p2[correct_idx + 1].weil_pairing(G, p2 + 1)
st = time.time()
dlog = w2.log(w1)
en = time.time()
print(f"{dlog = }, took {en - st:.2f}s.")
exit()
'''
# dlog = 860437940168965817900625942259, took 403.81s.


dlog = 860437940168965817900625942259
res_p2 = [dat_p2[i] * dlog == dat_p2[i + 1] for i in range(255)]
assert 255 > res_p2.count(True) > 130


def dlog_power(P, Q, p, o, E):
	EQp = E.change_ring(Qp(p))
	Pmul = EQp(P) * o
	Qmul = EQp(Q) * o

	dlog = ZZ((Qmul[0] / Qmul[1]) / (Pmul[0] / Pmul[1]))

	# assert Pmul * dlog == Qmul
	return dlog

E = EllipticCurve(Zmod(p2^2), [a, b])
dat_p2 = [E(P) for P in dat]

dlog_correct = dlog_power(dat_p2[correct_idx + 1], dat_p2[correct_idx], p2, o, E)
res_p2_power = [dlog_power(dat_p2[i + 1], dat_p2[i], p2, o, E) == dlog_correct for i in trange(255)]

assert 255 > res_p2_power.count(True) > 130

# 3, p3^3, supersingular curve, distorsion map
E = EllipticCurve(GF(p3), [a, b])
assert E.is_supersingular()
# print(E)
# Elliptic Curve defined by y^2 = x^3 + 1508611169675476373544814188711 over Finite Field of size 2717597692908121319788497985451
# a = 0
o = E.order()
assert o == p3 + 1
Fp2 = GF(p3^2)
z = Fp2(1).nth_root(3)
assert z != 1

E = EllipticCurve(Fp2, [a, b])

def distorsion_map(P):
	x, y = P.xy()
	return E(x * z, y)

dat_p3 = [E(P) for P in dat]
assert dat_p3[0].order() == o
dat_p3_distorsion = [distorsion_map(P) for P in dat_p3]

res_p3 = [ dat_p3[correct_idx].weil_pairing(dat_p3_distorsion[i + 1], p3 + 1)
		== dat_p3[correct_idx + 1].weil_pairing(dat_p3_distorsion[i], p3 + 1)
		for i in trange(255)]

assert 255 > res_p3.count(True) > 130



E = EllipticCurve(Zmod(p3^3), [a, b])
dat_p3 = [E(P) for P in dat]

dlog_correct = dlog_power(dat_p3[correct_idx + 1], dat_p3[correct_idx], p3, o, E)
res_p3_power = [dlog_power(dat_p3[i + 1], dat_p3[i], p3, o, E) == dlog_correct for i in trange(255)]

assert 255 > res_p3_power.count(True) > 130



# 4, p4^2, supersingular curve, distorsion map
E = EllipticCurve(GF(p4), [a, b])
assert E.is_supersingular()
# print(E)
# Elliptic Curve defined by y^2 = x^3 + 201486157873867982115091945503042086637219431930076933476606014*x over Finite Field of size 324094280281900209908870811008292068290746348301400744740589987
# b = 0
o = E.order()
assert o == p4 + 1
Fp2 = GF(p4^2)
z = Fp2(-1).nth_root(2)

E = EllipticCurve(Fp2, [a, b])

def distorsion_map(P):
	x, y = P.xy()
	return E(-x, y * z)

dat_p4 = [E(P) for P in dat]
assert dat_p4[0].order() == o
dat_p4_distorsion = [distorsion_map(P) for P in dat_p4]

res_p4 = [ dat_p4[correct_idx].weil_pairing(dat_p4_distorsion[i + 1], p4 + 1)
		== dat_p4[correct_idx + 1].weil_pairing(dat_p4_distorsion[i], p4 + 1)
		for i in trange(255)]

assert 255 > res_p4.count(True) > 130


E = EllipticCurve(Zmod(p4^2), [a, b])
dat_p4 = [E(P) for P in dat]

dlog_correct = dlog_power(dat_p4[correct_idx + 1], dat_p4[correct_idx], p4, o, E)
res_p4_power = [dlog_power(dat_p4[i + 1], dat_p4[i], p4, o, E) == dlog_correct for i in trange(255)]

assert 255 > res_p4_power.count(True) > 130



# Final

res_list = [res_p1, res_p2, res_p2_power, res_p3, res_p3_power, res_p4, res_p4_power]

res = [all(r[i] for r in res_list) for i in range(255)]

for i in range(7):
	res_without = []
	for j in range(7):
		if i == j:
			continue
		res_without.append(res_list[j])
	res_fail = [all(r[i] for r in res_without) for i in range(255)]

	assert res_fail != res


from Crypto.Cipher import AES

for front in range(2):
	key = 0
	keybits = [front] + res
	for i in range(256):
		key += keybits[i] << i

	key = int(key).to_bytes(32)

	flag = AES.new(key, AES.MODE_CTR, nonce=bytes(12)).decrypt(enc_flag)
	try:
		print(flag.decode())
	except:
		pass
