from pwn import *
import os
from tqdm import trange
import time
from myAES import myAES as AES
import random

os.system("gcc -o myAES myAES.c -O3")

# io = process(["python3", "chall.py"])
# io = remote("52.231.142.22", 3771)
io = remote("haari.me", 3771)

def communicate(msgs, enc):
	cmd = b"e"
	if enc == False:
		cmd = b"d"

	res = []

	l = len(msgs)
	for j in range(l):
		io.sendline(cmd)
		io.sendline(bytes.hex(msgs[j]).encode())
	for j in range(l):
		io.recvuntil(b": ")
		ct = bytes.fromhex(io.recvline().decode())
		res.append(ct)

	return res

if __name__ == "__main__":

	blocksize = 24
	nround = 20
	batch = 5000

	AES.n_rounds = nround
	AES.blocksize = blocksize

	encrypt = lambda msgs: communicate(msgs, True)
	decrypt = lambda msgs: communicate(msgs, False)

	real_sbox = AES.s_box[:]

	start = time.time()

	for rnd in range(3):

		res_sbox = [[True] * 256 for _ in range(blocksize)]
		res_inv = [[True] * 256 for _ in range(blocksize)]

		diff = [False] + [True] * 255
		invdiff = [False] + [True] * 255

		unique = False



		while True:
			st = [os.urandom(blocksize) for _ in range(batch)]
			enc = encrypt(st)
			dec = decrypt(enc)

			nice_pt = []
			nice_ct = []

			cipher = AES(bytes(blocksize))

			for i in range(batch):
				if st[i] == dec[i]:
					nice_pt.append(st[i])

					e = cipher.bytes2matrix(enc[i])
					cipher.inv_shift_rows(e)
					e = cipher.matrix2bytes(e)
					nice_ct.append(e)

			for msg in nice_pt:
				for i in range(blocksize):
					res_sbox[i][msg[i]] = False

			for msg in nice_ct:
				for i in range(blocksize):
					res_inv[i][msg[i]] = False

			print()

			if not unique:
				for i in range(256):
					if diff[i]:
						for idx in range(blocksize):
							chk1 = False
							for j in range(256):
								if res_sbox[idx][j] and res_sbox[idx][j ^ i]:
									chk1 = True
									break
							if not chk1:
								diff[i] = False
								break

				for i in range(256):
					if invdiff[i]:
						for idx in range(blocksize):
							chk1 = False
							for j in range(256):
								if res_inv[idx][j] and res_inv[idx][j ^ i]:
									chk1 = True
									break
							if not chk1:
								invdiff[i] = False
								break
				print(f"pos: {sum(diff)}, {sum(invdiff)}")

				if sum(diff) == 1 and sum(invdiff) == 1:
					unique = True
					diff = diff.index(True)
					invdiff = invdiff.index(True)

			if unique:
				print(f"diff: {diff}, {invdiff}")

				for idx in range(blocksize):
					for i in range(256):
						if not res_sbox[idx][i]:
							res_sbox[idx][i ^ diff] = False

					for i in range(256):
						if not res_inv[idx][i]:
							res_inv[idx][i ^ invdiff] = False


			cnt1 = []
			for i in range(blocksize):
				kk = []
				for j in range(256):
					if res_sbox[i][j]:
						kk.append(j)

				cnt1.append(len(kk))

			cnt2 = []
			for i in range(blocksize):
				kk = []
				for j in range(256):
					if res_inv[i][j]:
						kk.append(j)

				cnt2.append(len(kk))

			print(cnt1)
			print(f"{time.time() - start:.2f}s passed.")

			if cnt1 == [2] * blocksize:
				break

		key_pairs = []

		for i in range(blocksize):
			kk = []
			for j in range(256):
				if res_sbox[i][j]:
					kk.append(j)
			key_pairs.append(kk)

		sbox = real_sbox[:]

		candidate = []

		for i in range(256):
			if sbox[i] ^ sbox[i ^ diff] == invdiff:
				candidate.append([i, i ^ diff])
		try:
			assert len(candidate) == 2
			assert candidate[0][::-1] == candidate[1]
		except:
			print("unlucky")
			exit()

		fuckup1, fuckup2 = candidate[0]

		for i in range(blocksize):
			key_pairs[i][0] ^= fuckup2
			key_pairs[i][1] ^= fuckup2

		pt = os.urandom(blocksize)
		ct = encrypt([pt])[0]
		
		key1 = bytes([key_pairs[i][0] for i in range(blocksize)])
		key2 = bytes([key_pairs[i][1] for i in range(blocksize)])

		param = [blocksize, nround, fuckup1, fuckup2] + list(key1 + key2 + pt + ct)

		f = open("param", "w")

		f.write(f"{time.time() - start:.2f} ")
		for byte in param:
			f.write(str(byte) + " ")
		f.close()

		os.system("./myAES")

		f = open("key", "r")
		key = f.read().split(" ")[:-1]
		key = bytes([int(k) for k in key])
		f.close()

		os.remove("param")
		os.remove("key")

		io.sendlineafter(b"> ", b"v")
		io.sendlineafter(b"> ", bytes.hex(key).encode())


	io.interactive()