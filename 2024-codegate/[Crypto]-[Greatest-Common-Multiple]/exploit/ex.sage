from Crypto.Cipher import AES
from pwn import process, remote, xor
import os
import random
from tqdm import trange, tqdm
from itertools import product
from time import time
import hashlib



# Helper

F.<a> = GF(2^128, modulus=x^128 + x^7 + x^2 + x + 1)
mod = 2^128 + 2^7 + 2^2 + 2 + 1

def bytes_to_n(b):
	v = int.from_bytes(nullpad(b), 'big')
	return int(f"{v:0128b}"[::-1], 2)

def bytes_to_poly(b):
	return F.from_integer(bytes_to_n(b))

def poly_to_n(p):
	v = p.to_integer()
	return int(f"{v:0128b}"[::-1], 2)
	
def poly_to_bytes(p):
	return poly_to_n(p).to_bytes(16, 'big')

def length_block(lad, lct):
	return int(lad * 8).to_bytes(8, 'big') + int(lct * 8).to_bytes(8, 'big')

def nullpad(msg):
	return bytes(msg) + b'\x00' * (-len(msg) % 16)

def calculate_tag(key, ct, nonce, ad):
	y = AES.new(key, AES.MODE_ECB).encrypt(bytes(16))
	s = AES.new(key, AES.MODE_ECB).encrypt(nonce + b"\x00\x00\x00\x01")
	assert len(nonce) == 12
	# I was lazy to find one for other length nonces, not really needed for this challenge

	y = bytes_to_poly(y)

	l = length_block(len(ad), len(ct))

	blocks = nullpad(ad) + nullpad(ct)
	bl = len(blocks) // 16

	blocks = [blocks[16 * i:16 * (i + 1)] for i in range(bl)]
	blocks.append(l)
	blocks.append(s)

	tag = F(0)
	
	for exp, block in enumerate(blocks[::-1]):
		tag += y^exp * bytes_to_poly(block)

	tag = poly_to_bytes(tag)

	return tag

def check():
	key = os.urandom(16)
	nonce = os.urandom(12)

	ad = os.urandom(os.urandom(1)[0])
	pt = os.urandom(os.urandom(1)[0])
	
	cipher = AES.new(key, AES.MODE_GCM, nonce)
	cipher.update(ad)
	ct, tag = cipher.encrypt_and_digest(pt)

	assert tag == calculate_tag(key, ct, nonce, ad)



# Implementations

def tag():
	io.sendline(b"tag")
	io.recvuntil(b"tag: ")
	return bytes.fromhex(io.recvline().decode())

def u1():
	io.sendline(b"u1")
	io.sendline(b"tag")
	io.recvuntil(b"tag: ")
	return bytes.fromhex(io.recvline().decode())

def u2():
	io.sendline(b"u2")
	io.sendline(b"tag")
	io.recvuntil(b"tag: ")
	return bytes.fromhex(io.recvline().decode())

def solve1():
	cur = tag()
	dats = []

	num_dat = 150
	io.sendlines([b"u1", b"tag"] * num_dat)

	for _ in range(num_dat):
		io.recvuntil(b"tag: ")
		new = bytes.fromhex(io.recvline().decode())

		dat = xor(new, cur)
		cur = new

		dat = bytes_to_n(dat)
		basis = [dat]
		for i in range(127):
			basis.append(basis[-1] << 1)
			if basis[-1] & (1 << 128):
				basis[-1] ^^= mod
		
		vecs = []
		for i in range(32):
			vecs.append(vector(GF(2), [basis[j] >> (i + 96) for j in range(128)]))

		dats.append(vecs)

	found = set()

	while True:
		idxs = random.sample(range(num_dat), 5)

		M = []
		for idx in idxs:
			M += dats[idx]
		M = Matrix(M)

		basis = M.right_kernel().basis()

		if len(basis) == 1:
			res = F([int(t) for t in basis[0]])
			
			found.add(res)
			
			if len(found) == 2:
				break

	f1, f2 = list(found)

	y = 1 / f1.sqrt()
	if y^(-3) == f2:
		return y

	y = 1 / f2.sqrt()
	assert y^(-3) == f1

	return y

def solve2():
	cnt = 0
	pre = []
	for exp in range(20):
		pre.append([list(y^exp * a^i) for i in range(128)])
		
	while True:
		cnt += 1
		print(f"Try {cnt}")
		# Reset all values to 12 bytes
		io.sendlines([b"u1"] * 50)

		io.sendline(b"tag")
		io.sendlines([b"u2", b"tag"] * 6)

		tags = []

		for _ in range(7):
			io.recvuntil(b"tag: ")
			tags.append(bytes.fromhex(io.recvline().decode()))
		
		c1, c2 = True, True

		f = bytes_to_poly(xor(tags[2], tags[3])) + (bytes_to_poly(length_block(12, 36)) + bytes_to_poly(length_block(12, 48))) * y
		f /= y^2 * a^32
		f = f.to_integer()
		
		if f >> 96 != 0:
			c1 = False

		f = bytes_to_poly(xor(tags[5], tags[6])) + (bytes_to_poly(length_block(36, 48)) + bytes_to_poly(length_block(48, 48))) * y
		f /= y^5 * a^32
		f = f.to_integer()
		
		if f >> 96 != 0:
			c1 = False


		f = bytes_to_poly(xor(tags[2], tags[3])) + (bytes_to_poly(length_block(36, 12)) + bytes_to_poly(length_block(48, 12))) * y
		f /= y^3 * a^32
		f = f.to_integer()
		
		if f >> 96 != 0:
			c2 = False

		f = bytes_to_poly(xor(tags[5], tags[6])) + (bytes_to_poly(length_block(48, 36)) + bytes_to_poly(length_block(48, 48))) * y
		f /= y^2 * a^32
		f = f.to_integer()
		
		if f >> 96 != 0:
			c2 = False

		assert (c1 and c2) == False

		if c1:
			base_it = [1, 1, 1, 0, 0, 0]
		elif c2:
			base_it = [0, 0, 0, 1, 1, 1]
		else:
			continue

		tag_n = 12

		io.sendlines([b"u2", b"tag"] * (tag_n - 7))
		for _ in range(tag_n - 7):
			io.recvuntil(b"tag: ")
			tag = bytes.fromhex(io.recvline().decode())
			tags.append(tag)

		tags = [bytes_to_poly(tag) for tag in tags]

		assert len(tags) == tag_n

		for it in trange(2^(tag_n - 7)):
			ad_l = 96
			ct_l = 96

			it = base_it + [(it >> i) & 1 for i in range(tag_n - 4)]

			ad_tot = ad_l + 96 * ((tag_n - 1) - sum(it))
			ct_tot = ct_l + 96 * sum(it)

			M = Matrix(GF(2), tag_n * 128, (ad_tot + ct_tot + 128))
			r = []

			for bl in range(tag_n):
				if bl > 0:
					cur = it[bl - 1]
					if cur == 0:
						ad_l += 96
					else:
						ct_l += 96

				res = tags[bl] + bytes_to_poly(length_block(ad_l // 8, ct_l // 8)) * y
				r += list(res)
				
				ad_b = (ad_l + 127) // 128
				ct_b = (ct_l + 127) // 128

				exp = 2 + ad_b + ct_b
				for i in range(ad_l):
					if i % 128 == 0:
						exp -= 1

					for j in range(128):
						M[bl * 128 + j, i] = pre[exp][i % 128][j]

				exp = 2 + ct_b
				for i in range(ct_l):
					if i % 128 == 0:
						exp -= 1
					
					for j in range(128):
						M[bl * 128 + j, i + ad_tot] = pre[exp][i % 128][j]

				for i in range(128):
					M[bl * 128 + i, i + ad_tot + ct_tot] = 1

			assert ad_tot == ad_l
			assert ct_tot == ct_l

			r = vector(GF(2), r)

			try:
				res = M.solve_right(r)
			except ValueError as e:
				continue

			basis = M.right_kernel().basis()

			l = len(basis)
			

			if l > 10:
				cands = None
				break
				

			cands = []

			for itt in product(range(2), repeat=l):
				v = res
				for i, b in enumerate(itt):
					v += b * basis[i]
				assert M * v == r

				vs = [v[:ad_tot], v[ad_tot:ad_tot + ct_tot], v[ad_tot + ct_tot:]]
				
				for idx in range(3):
					v = list(vs[idx])
					v_bytes = b""
					for i in range(0, len(v), 128):
						block = [int(t) for t in v[i:i + 128]]
						v_bytes += poly_to_bytes(F(block))[:len(block) // 8]
					vs[idx] = v_bytes

				cands.append(vs)

			break

		print(f"{l} basis")
		return cands

def solve3():
	io.sendline(b"")

	ct = b""
	ad = b""
	s = cands[0][2]
	l = length_block(len(ad), len(ct))

	blocks = nullpad(ad) + nullpad(ct)
	bl = len(blocks) // 16

	blocks = [blocks[16 * i:16 * (i + 1)] for i in range(bl)]
	blocks.append(l)
	blocks.append(s)

	tag = F(0)
	
	for exp, block in enumerate(blocks[::-1]):
		tag += y^exp * bytes_to_poly(block)

	tag = poly_to_bytes(tag)

	io.sendlineafter(b"tag: ", bytes.hex(tag).encode())

	flag = io.recvline()[:-1].decode()

	assert flag[0] != "T"
	return flag


def solve_PoW():
	io.recvuntil(b"b'")
	nonce = io.recvuntil(b"'")[:-1]
	io.recvuntil(b" = ")
	hsh = bytes.fromhex(io.recvline()[:-1].decode())

	for n in trange(2^26):
		if hashlib.md5(str(n).encode() + nonce).digest() == hsh:
			break

	io.sendlineafter(b"): ", str(n).encode())

def solve():
	global y, cands

	solve_PoW()
	
	try:
		y = solve1()
		cands = solve2()
		if cands == None:
			return None
		return solve3()
	except KeyboardInterrupt:
		exit()
	except:
		return None



# Main

if __name__ == "__main__":
	check()

	st = time()

	while True:
		# io = process(["python3", "chall.py"])
		io = remote("13.124.214.119", 9999r)
		
		flag = solve()
		io.close()
		
		if flag != None:
			break
		
	print(flag)
	en = time()
	print(f"{(en - st):.2f}s taken.")
