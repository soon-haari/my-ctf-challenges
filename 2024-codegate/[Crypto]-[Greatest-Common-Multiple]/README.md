# Crypto - Greatest Common Multiple

### 출제자
- 김민순 (@soon_haari)

### 문제 세팅 방법

1. `for_organizer` 폴더로 이동
2. `Dockerfile`, `docker-compose.yml`의 port 세팅 상황에 맟게 변경
3. 아래 명령어 실행

```
$ docker-compose up -d
```

### 출제 지문
My boss 1nteger_c said we will come back with a better GCM challenge. I hereby present, the **Greatest Common Multiple**.

### 문제 풀이(writeup)

AES-GCM 모드를 사용한 문제이지만, 대부분의 GCM 문제에서 등장하는 살라만더 기법을 넘어 태그 연산 과정을 직접 분석해야 합니다. 먼저 서버에서 가능한 기능은 3가지 뿐입니다.

1. 현재 설정된 Plaintext와 Associated data로 암호화를 진행한 후의 태그 확인, 그러나 평문과 암호문 중 그 어느 것도 알 수 없습니다.
2. Plaintext와 Associated data를 랜덤으로 하나 골라 `urandom(12)`로 설정 (`u1`)
3. Plaintext와 Associated data를 랜덤으로 하나 골라 `urandom(12)`를 추가(Concatenation) (`u2`)

따라서 얻을 수 있는 정보는 각 상황의 태그뿐이고, 최종 목표는 0바이트의 Plaintext, 0바이트의 Associated data로 암호화 시의 태그인 `AES.new(key, AES.MODE_ECB).encrypt(nonce + b"\x00\x00\x00\x01")`의 값을 알아내는 것입니다. 제 코드에서는 이 값을 $s$로 칭하였고, 태그 생성 과정 시 각 블록마다 거듭제곱으로 곱해지는 값을 $y$로 칭하였습니다.

#### 1. $y$값 구하기
Plaintext와 Associated data 모두 미지의 12바이트인 상황입니다. 그러나 `u1` 옵션을 사용하면 둘 중 하나만 다른 12바이트로 업데이트됩니다. 따라서 `u1` 옵션 사용 전후의 태그를 XOR하면 다음과 같은 식을 얻을 수 있습니다. Plaintext가 업데이트되었다고 가정하겠습니다. Associated data로도 풀이 가능합니다.

$$tag_0 \oplus tag_1 = (pt_0 \oplus pt_1) \times y^b$$

이 식에서 16바이트의 $tag_0 \oplus tag_1$ 값을 알고 있고, $(pt_0 \oplus pt_1)$는 12바이트 이하, 즉 $\mathbb{F}_{2^{128}}$에서 상위 32개의 계수가 0임을 알 수 있습니다.

일반적인 환 혹은 체 위에서의 연산이었다면 LLL 알고리즘 등을 사용해 해결할 수 있겠지만, $\mathbb{F}_{2^{128}}$ 위에서 진행되는 연산이기 때문에 $y^b$의 128개 계수에 대한 선형식을 32개 세울 수 있습니다. 이를 4회 이상 반복하여 128개의 식을 얻으면 $y^b, y$의 값을 복구 가능합니다. `u1` 옵션 사용 시 Plaintext와 Associated data 중에서 어느 것이 업데이트되는지 모르기 때문에 여러 가능성을 모두 고려해야 합니다. 경우의 수가 많이 없어, 배치로 정보 수집 후 가능한 값을 조사하면 오랜 시간이 걸리지 않고 $y$를 구할 수 있습니다.

위에서 언급했듯이, LLL 알고리즘을 사용한 방법으로도 $y$를 구할 수 있습니다. 그러나 $s$를 구하려면 너무 큰 격자가 필요합니다. 따라서 선형방정식을 해결하는 것이 훨씬 효율적입니다.

#### 2. $s$값 구하기
$y$를 알아냈다는 가정 하에서, Plaintext 12바이트, Associated data 12바이트, $s$ 16바이트로 총 $40 \cdot 8$ = 320개의 미지 비트가 존재하고, 16바이트 태그 1개를 알고 있으므로 $16 \cdot 8$ = 128개의 선형식을 알고 있는 상태입니다. 따라서 이 정보만으로는 $s$를 구할 수 없습니다.

`u2` 옵션을 사용하면 어떻게 되는지 간략히 분석해보겠습니다. 12바이트가 추가되기 때문에 미지 비트 $12 \cdot 8$ = 96개가 추가되고, 새로운 태그가 주어지기 때문에 선형식이 128개가 추가됩니다. 따라서 얻은 정보가 새로운 정보보다 32개 더 많습니다.

$\frac{320 - 128}{32}$ = 6으로 `u2` 옵션을 이용한 수집을 6회 이상 진행하면 선형방정식을 해결 가능합니다.

구현 난이도도 굉장히 높고, 유의점이 몇 가지 있습니다.

1. `u2` 옵션도 마찬가지로 Plaintext, Associated data 중 어느 것이 업데이트되는지 모르기 때문에 여러 가능성을 고려해야 합니다. 30초 내에 진행하기 위해서는 효율적인 방법을 탐색해야 하고, 의도된 풀이조차도 약 10번 중 1번 꼴로 30초 내에 풀이가 성공합니다.
2. `u2` 옵션을 사용해도 바이트 길이, Null byte 패딩 등의 이슈로 추가되는 미지 비트의 수와 추가되는 선형식의 수가 같은 경우가 존재합니다. 정확히 말하면 추가되는 선형식 128개 중 32개가 중복됩니다.
3. 최종적으로 얻은 선형방적식의 Nullspace는 0, 2, 4, 6, 8, 10, 12개 등으로 짝수개의 basis를 가짐을 실험적으로 알 수 있습니다. 0개의 경우 해가 유일하기 때문에 문제 해결이 가능하고, 2개의 경우는 $2^2$ = 4개의 해가 존재하기 때문에 $\frac{3}{4}$의 확률로 해결에 실패합니다. 시간 제한과 여러 해의 존재성 이 두 개의 이유 때문에 여러 시도가 필요합니다.

### 플래그
codegate2024{Is_it_normal_if_some_data_is_obtainable_just_with_tag?...F_2^128's_super_property}